From 9e2a251094c838173beed0aaa30dd22a7518c220 Mon Sep 17 00:00:00 2001
From: Hongxu Jia <hongxu.jia@windriver.com>
Date: Mon, 14 Nov 2022 13:43:30 +0800
Subject: [PATCH 5/6] cpython: support Python 3.11

Backport patches from upstream to support Python 3.11

Upstream-Status: Backport [https://github.com/cython/cython/commit/776957022d062ed24edea192b719720118ee3576,
https://github.com/cython/cython/commit/afc00fc3ba5d43c67151c0039847a526e7b627a5]

Signed-off-by: Hongxu Jia <hongxu.jia@windriver.com>
---
 tensorflow/workspace2.bzl                     |   1 +
 .../systemlibs/0001-support-Python-3.11.patch | 422 ++++++++++++++++++
 2 files changed, 423 insertions(+)
 create mode 100644 third_party/systemlibs/0001-support-Python-3.11.patch

diff --git a/tensorflow/workspace2.bzl b/tensorflow/workspace2.bzl
index b3c21d4a686..6f456371872 100644
--- a/tensorflow/workspace2.bzl
+++ b/tensorflow/workspace2.bzl
@@ -698,6 +698,7 @@ def _tf_repositories():
     tf_http_archive(
         name = "cython",
         build_file = "//third_party:cython.BUILD",
+        patch_file = ["//third_party/systemlibs:0001-support-Python-3.11.patch"],
         sha256 = "d530216e015fd365bf3327a176e0073d0e5b8d48781f387336459f10032d776f",
         strip_prefix = "cython-3.0.0a10",
         system_build_file = "//third_party/systemlibs:cython.BUILD",
diff --git a/third_party/systemlibs/0001-support-Python-3.11.patch b/third_party/systemlibs/0001-support-Python-3.11.patch
new file mode 100644
index 00000000000..5f1069f5524
--- /dev/null
+++ b/third_party/systemlibs/0001-support-Python-3.11.patch
@@ -0,0 +1,422 @@
+From 741c244b185c08fa67a1d59f2dc3081770de5b35 Mon Sep 17 00:00:00 2001
+From: scoder <stefan_ml@behnel.de>
+Date: Sun, 23 Jan 2022 22:53:44 +0100
+Subject: [PATCH] support Python 3.11
+
+Adapt to "exc_info" changes in CPython 3.11a4 (GH-4584)
+
+Adapt to "exc_info" changes in CPython 3.11a4, where "->exc_type" and "->exc_traceback" are gone and now get inferred from "->exc_value".
+
+Closes https://github.com/cython/cython/issues/4500
+
+Import internal CPython frame header file in Python 3.11 (GH-4667)
+
+In https://github.com/python/cpython/pull/31530
+https://bugs.python.org/issue46836
+
+Signed-off-by: Stefan Behnel <stefan_ml@behnel.de>
+
+the `_frame` struct was moved to an internal header, however the public API is
+primarily read-only, and Cython needs to build PyFrameObjects so still import
+the internal headers.
+
+Also sets the Py_BUILD_CORE define for py311a6, trying to restrict it to the frame header.
+
+Signed-off-by: Thomas A Caswell <tcaswell@gmail.com>
+Signed-off-by: Hongxu Jia <hongxu.jia@windriver.com>
+---
+ Cython/Utility/Coroutine.c      |  55 +++++++++++++---
+ Cython/Utility/Exceptions.c     | 108 +++++++++++++++++++++++++-------
+ Cython/Utility/ObjectHandling.c |   7 +++
+ Cython/Utility/Profile.c        |   6 ++
+ 4 files changed, 146 insertions(+), 30 deletions(-)
+
+diff --git a/Cython/Utility/Coroutine.c b/Cython/Utility/Coroutine.c
+index e708464..3e7e217 100644
+--- a/Cython/Utility/Coroutine.c
++++ b/Cython/Utility/Coroutine.c
+@@ -499,6 +499,12 @@ static int __pyx_Generator_init(PyObject *module); /*proto*/
+ //@requires: ModuleSetupCode.c::IncludeStructmemberH
+ 
+ #include <frameobject.h>
++#if PY_VERSION_HEX >= 0x030b00a6
++  #ifndef Py_BUILD_CORE
++    #define Py_BUILD_CORE 1
++  #endif
++  #include "internal/pycore_frame.h"
++#endif
+ 
+ #define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
+ 
+@@ -601,6 +607,9 @@ static int __Pyx_PyGen__FetchStopIterationValue(PyThreadState *$local_tstate_cna
+ 
+ static CYTHON_INLINE
+ void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *exc_state) {
++#if PY_VERSION_HEX >= 0x030B00a4
++    Py_CLEAR(exc_state->exc_value);
++#else
+     PyObject *t, *v, *tb;
+     t = exc_state->exc_type;
+     v = exc_state->exc_value;
+@@ -613,6 +622,7 @@ void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *exc_state) {
+     Py_XDECREF(t);
+     Py_XDECREF(v);
+     Py_XDECREF(tb);
++#endif
+ }
+ 
+ #define __Pyx_Coroutine_AlreadyRunningError(gen)  (__Pyx__Coroutine_AlreadyRunningError(gen), (PyObject*)NULL)
+@@ -718,14 +728,21 @@ PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value, i
+     // - do not touch external frames and tracebacks
+ 
+     exc_state = &self->gi_exc_state;
+-    if (exc_state->exc_type) {
++    if (exc_state->exc_value) {
+         #if CYTHON_COMPILING_IN_PYPY
+         // FIXME: what to do in PyPy?
+         #else
+         // Generators always return to their most recent caller, not
+         // necessarily their creator.
+-        if (exc_state->exc_traceback) {
+-            PyTracebackObject *tb = (PyTracebackObject *) exc_state->exc_traceback;
++        PyObject *exc_tb;
++        #if PY_VERSION_HEX >= 0x030B00a4
++        // owned reference!
++        exc_tb = PyException_GetTraceback(exc_state->exc_value);
++        #else
++        exc_tb = exc_state->exc_traceback;
++        #endif
++        if (exc_tb) {
++            PyTracebackObject *tb = (PyTracebackObject *) exc_tb;
+             PyFrameObject *f = tb->tb_frame;
+ 
+             assert(f->f_back == NULL);
+@@ -737,6 +754,9 @@ PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value, i
+             Py_XINCREF(tstate->frame);
+             f->f_back = tstate->frame;
+             #endif
++            #if PY_VERSION_HEX >= 0x030B00a4
++            Py_DECREF(exc_tb);
++            #endif
+         }
+         #endif
+     }
+@@ -778,17 +798,28 @@ static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStr
+     // Don't keep the reference to f_back any longer than necessary.  It
+     // may keep a chain of frames alive or it could create a reference
+     // cycle.
+-    PyObject *exc_tb = exc_state->exc_traceback;
+-
+-    if (likely(exc_tb)) {
+ #if CYTHON_COMPILING_IN_PYPY
+     // FIXME: what to do in PyPy?
+ #else
++    PyObject *exc_tb;
++
++    #if PY_VERSION_HEX >= 0x030B00a4
++    if (!exc_state->exc_value) return;
++    // owned reference!
++    exc_tb = PyException_GetTraceback(exc_state->exc_value);
++    #else
++    exc_tb = exc_state->exc_traceback;
++    #endif
++
++    if (likely(exc_tb)) {
+         PyTracebackObject *tb = (PyTracebackObject *) exc_tb;
+         PyFrameObject *f = tb->tb_frame;
+         Py_CLEAR(f->f_back);
+-#endif
++        #if PY_VERSION_HEX >= 0x030B00a4
++        Py_DECREF(exc_tb);
++        #endif
+     }
++#endif
+ }
+ 
+ static CYTHON_INLINE
+@@ -1133,9 +1164,13 @@ static PyObject *__Pyx_Coroutine_Throw(PyObject *self, PyObject *args) {
+ }
+ 
+ static CYTHON_INLINE int __Pyx_Coroutine_traverse_excstate(__Pyx_ExcInfoStruct *exc_state, visitproc visit, void *arg) {
++#if PY_VERSION_HEX >= 0x030B00a4
++    Py_VISIT(exc_state->exc_value);
++#else
+     Py_VISIT(exc_state->exc_type);
+     Py_VISIT(exc_state->exc_value);
+     Py_VISIT(exc_state->exc_traceback);
++#endif
+     return 0;
+ }
+ 
+@@ -1432,9 +1467,13 @@ static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
+     gen->resume_label = 0;
+     gen->classobj = NULL;
+     gen->yieldfrom = NULL;
++    #if PY_VERSION_HEX >= 0x030B00a4
++    gen->gi_exc_state.exc_value = NULL;
++    #else
+     gen->gi_exc_state.exc_type = NULL;
+     gen->gi_exc_state.exc_value = NULL;
+     gen->gi_exc_state.exc_traceback = NULL;
++    #endif
+ #if CYTHON_USE_EXC_INFO_STACK
+     gen->gi_exc_state.previous_item = NULL;
+ #endif
+@@ -2168,7 +2207,7 @@ static void __Pyx__ReturnWithStopIteration(PyObject* value) {
+     #if CYTHON_FAST_THREAD_STATE
+     __Pyx_PyThreadState_assign
+     #if CYTHON_USE_EXC_INFO_STACK
+-    if (!$local_tstate_cname->exc_info->exc_type)
++    if (!$local_tstate_cname->exc_info->exc_value)
+     #else
+     if (!$local_tstate_cname->exc_type)
+     #endif
+diff --git a/Cython/Utility/Exceptions.c b/Cython/Utility/Exceptions.c
+index 14ee417..de047b7 100644
+--- a/Cython/Utility/Exceptions.c
++++ b/Cython/Utility/Exceptions.c
+@@ -339,7 +339,7 @@ static _PyErr_StackItem *
+ __Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
+ {
+     _PyErr_StackItem *exc_info = tstate->exc_info;
+-    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
++    while ((exc_info->exc_value == NULL || exc_info->exc_value == Py_None) &&
+            exc_info->previous_item != NULL)
+     {
+         exc_info = exc_info->previous_item;
+@@ -405,12 +405,21 @@ static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
+     #if CYTHON_USE_EXC_INFO_STACK
+     {
+         _PyErr_StackItem *exc_info = tstate->exc_info;
++      #if PY_VERSION_HEX >= 0x030B00a4
++        tmp_value = exc_info->exc_value;
++        exc_info->exc_value = local_value;
++        tmp_type = NULL;
++        tmp_tb = NULL;
++        Py_XDECREF(local_type);
++        Py_XDECREF(local_tb);
++      #else
+         tmp_type = exc_info->exc_type;
+         tmp_value = exc_info->exc_value;
+         tmp_tb = exc_info->exc_traceback;
+         exc_info->exc_type = local_type;
+         exc_info->exc_value = local_value;
+         exc_info->exc_traceback = local_tb;
++      #endif
+     }
+     #else
+     tmp_type = tstate->exc_type;
+@@ -450,35 +459,44 @@ static CYTHON_INLINE void __Pyx_ReraiseException(void) {
+     PyObject *type = NULL, *value = NULL, *tb = NULL;
+ #if CYTHON_FAST_THREAD_STATE
+     PyThreadState *tstate = PyThreadState_GET();
+-    #if CYTHON_USE_EXC_INFO_STACK
++  #if CYTHON_USE_EXC_INFO_STACK
+     _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+-    type = exc_info->exc_type;
+     value = exc_info->exc_value;
+-    tb = exc_info->exc_traceback;
++    #if PY_VERSION_HEX >= 0x030B00a4
++    if (unlikely(value == Py_None)) {
++        value = NULL;
++    } else if (value) {
++        Py_INCREF(value);
++        type = (PyObject*) Py_TYPE(value);
++        Py_INCREF(type);
++        tb = PyException_GetTraceback(value);
++    }
+     #else
++    type = exc_info->exc_type;
++    tb = exc_info->exc_traceback;
++    Py_XINCREF(type);
++    Py_XINCREF(value);
++    Py_XINCREF(tb);
++    #endif
++  #else
+     type = tstate->exc_type;
+     value = tstate->exc_value;
+     tb = tstate->exc_traceback;
+-    #endif
++    Py_XINCREF(type);
++    Py_XINCREF(value);
++    Py_XINCREF(tb);
++  #endif
+ #else
+     PyErr_GetExcInfo(&type, &value, &tb);
+ #endif
+-    if (!type || type == Py_None) {
+-#if !CYTHON_FAST_THREAD_STATE
++    if (unlikely(!type || type == Py_None)) {
+         Py_XDECREF(type);
+         Py_XDECREF(value);
+         Py_XDECREF(tb);
+-#endif
+         // message copied from Py3
+         PyErr_SetString(PyExc_RuntimeError,
+             "No active exception to reraise");
+     } else {
+-#if CYTHON_FAST_THREAD_STATE
+-        Py_INCREF(type);
+-        Py_XINCREF(value);
+-        Py_XINCREF(tb);
+-
+-#endif
+         PyErr_Restore(type, value, tb);
+     }
+ }
+@@ -504,24 +522,49 @@ static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject
+ 
+ #if CYTHON_FAST_THREAD_STATE
+ static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+-    #if CYTHON_USE_EXC_INFO_STACK
++  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
++    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
++    PyObject *exc_value = exc_info->exc_value;
++    if (exc_value == NULL || exc_value == Py_None) {
++        *value = NULL;
++        *type = NULL;
++        *tb = NULL;
++    } else {
++        *value = exc_value;
++        Py_INCREF(*value);
++        *type = (PyObject*) Py_TYPE(exc_value);
++        Py_INCREF(*type);
++        *tb = PyException_GetTraceback(exc_value);
++    }
++  #elif CYTHON_USE_EXC_INFO_STACK
+     _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+     *type = exc_info->exc_type;
+     *value = exc_info->exc_value;
+     *tb = exc_info->exc_traceback;
+-    #else
++    Py_XINCREF(*type);
++    Py_XINCREF(*value);
++    Py_XINCREF(*tb);
++  #else
+     *type = tstate->exc_type;
+     *value = tstate->exc_value;
+     *tb = tstate->exc_traceback;
+-    #endif
+     Py_XINCREF(*type);
+     Py_XINCREF(*value);
+     Py_XINCREF(*tb);
++  #endif
+ }
+ 
+ static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
++  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
++    _PyErr_StackItem *exc_info = tstate->exc_info;
++    PyObject *tmp_value = exc_info->exc_value;
++    exc_info->exc_value = value;
++    Py_XDECREF(tmp_value);
++    // TODO: avoid passing these at all
++    Py_XDECREF(type);
++    Py_XDECREF(tb);
++  #else
+     PyObject *tmp_type, *tmp_value, *tmp_tb;
+-
+     #if CYTHON_USE_EXC_INFO_STACK
+     _PyErr_StackItem *exc_info = tstate->exc_info;
+     tmp_type = exc_info->exc_type;
+@@ -541,6 +584,7 @@ static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject
+     Py_XDECREF(tmp_type);
+     Py_XDECREF(tmp_value);
+     Py_XDECREF(tmp_tb);
++  #endif
+ }
+ #endif
+ 
+@@ -560,8 +604,22 @@ static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value,
+ #if CYTHON_FAST_THREAD_STATE
+ static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+     PyObject *tmp_type, *tmp_value, *tmp_tb;
+-
+-    #if CYTHON_USE_EXC_INFO_STACK
++  #if CYTHON_USE_EXC_INFO_STACK && PY_VERSION_HEX >= 0x030B00a4
++    _PyErr_StackItem *exc_info = tstate->exc_info;
++    tmp_value = exc_info->exc_value;
++    exc_info->exc_value = *value;
++    if (tmp_value == NULL || tmp_value == Py_None) {
++        Py_XDECREF(tmp_value);
++        tmp_value = NULL;
++        tmp_type = NULL;
++        tmp_tb = NULL;
++    } else {
++        // TODO: avoid swapping these at all
++        tmp_type = (PyObject*) Py_TYPE(tmp_value);
++        Py_INCREF(tmp_type);
++        tmp_tb = PyException_GetTraceback(tmp_value);
++    }
++  #elif CYTHON_USE_EXC_INFO_STACK
+     _PyErr_StackItem *exc_info = tstate->exc_info;
+     tmp_type = exc_info->exc_type;
+     tmp_value = exc_info->exc_value;
+@@ -570,7 +628,7 @@ static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject *
+     exc_info->exc_type = *type;
+     exc_info->exc_value = *value;
+     exc_info->exc_traceback = *tb;
+-    #else
++  #else
+     tmp_type = tstate->exc_type;
+     tmp_value = tstate->exc_value;
+     tmp_tb = tstate->exc_traceback;
+@@ -578,7 +636,7 @@ static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject *
+     tstate->exc_type = *type;
+     tstate->exc_value = *value;
+     tstate->exc_traceback = *tb;
+-    #endif
++  #endif
+ 
+     *type = tmp_type;
+     *value = tmp_value;
+@@ -727,6 +785,12 @@ static void __Pyx_AddTraceback(const char *funcname, int c_line,
+ #include "compile.h"
+ #include "frameobject.h"
+ #include "traceback.h"
++#if PY_VERSION_HEX >= 0x030b00a6
++  #ifndef Py_BUILD_CORE
++    #define Py_BUILD_CORE 1
++  #endif
++  #include "internal/pycore_frame.h"
++#endif
+ 
+ #if CYTHON_COMPILING_IN_LIMITED_API
+ static void __Pyx_AddTraceback(const char *funcname, int c_line,
+diff --git a/Cython/Utility/ObjectHandling.c b/Cython/Utility/ObjectHandling.c
+index 5080283..0f0348f 100644
+--- a/Cython/Utility/ObjectHandling.c
++++ b/Cython/Utility/ObjectHandling.c
+@@ -2446,6 +2446,13 @@ static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args,
+   static size_t __pyx_pyframe_localsplus_offset = 0;
+ 
+   #include "frameobject.h"
++#if PY_VERSION_HEX >= 0x030b00a6
++  #ifndef Py_BUILD_CORE
++    #define Py_BUILD_CORE 1
++  #endif
++  #include "internal/pycore_frame.h"
++#endif
++
+   // This is the long runtime version of
+   //     #define __Pyx_PyFrame_GetLocalsplus(frame)  ((frame)->f_localsplus)
+   // offsetof(PyFrameObject, f_localsplus) differs between regular C-Python and Stackless Python.
+diff --git a/Cython/Utility/Profile.c b/Cython/Utility/Profile.c
+index 645ec95..20b599e 100644
+--- a/Cython/Utility/Profile.c
++++ b/Cython/Utility/Profile.c
+@@ -38,6 +38,12 @@
+   #include "compile.h"
+   #include "frameobject.h"
+   #include "traceback.h"
++#if PY_VERSION_HEX >= 0x030b00a6
++  #ifndef Py_BUILD_CORE
++    #define Py_BUILD_CORE 1
++  #endif
++  #include "internal/pycore_frame.h"
++#endif
+ 
+   #if CYTHON_PROFILE_REUSE_FRAME
+     #define CYTHON_FRAME_MODIFIER static
+-- 
+2.37.1
+
-- 
2.27.0

